import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import apiUtils from '../../global/utils/api';
import { convertListToMap, shouldFetch } from '../../global/utils/storeUtils';


const initialState = {
  /**
   * "byId" is an object map of all product items in the store. The map's keys are
   * the Mongo ids of the objects by default
   */
  byId: {},
  
  // defaultItem will just be a regular fetch, no need to give it a special spot in state.

  /**
   * "queries" is an object map of all server fetches for products. The map's keys are listArgs
   * in the case of list fetches and Mongo ids in the case of single fetches.
   * Each individual query looks like this:
   * 
   * @example {
   *  expirationDate: date
   *  receivedAt: date
   *  status: 'pending' || 'fulfilled' || 'rejected'
   *  // for lists
   *  ids: [mongoId, mongoId]
   *  // for singles
   *  id: mongoId
   * }
   */
  queries: {} // this can hold lists and single queries with the same meta. Instead of listArgs, singles would be indexed by id.
};

/**
 * The function below is called a thunk and allows us to perform async logic. It
 * can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
 * will call the thunk with the `dispatch` function as the first argument. Async
 * code can then be executed and other actions can be dispatched. Thunks are
 * typically used to make async requests.
 * 
 * In practice we won't dispatch these directly, they will be dispatched by productService.
 */

// CREATE
export const sendCreateProduct = createAsyncThunk(
  'product2/sendCreate',
  async (newProduct) => {
    const endpoint = `/api/products`;
    const response = await apiUtils.callAPI(endpoint, 'POST', newProduct);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// READ
export const fetchDefaultProduct = createAsyncThunk(
  'product2/fetchDefault',
  async () => {
    const endpoint = `/api/products/default`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const fetchSingleProduct = createAsyncThunk(
  'product2/fetchSingle',
  async (id) => {
    const endpoint = `/api/products/${id}`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const fetchProductList = createAsyncThunk(
  'product2/fetchList', // this is the action name that will show up in the console logger.
  async (listArgs) => {
    const endpoint = `/api/products?${listArgs}`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// UPDATE
export const sendUpdateProduct = createAsyncThunk(
  'product2/sendUpdate',
  async ({_id, ...updates}) => {
    const endpoint = `/api/products/${_id}`;
    const response = await apiUtils.callAPI(endpoint, 'PUT', updates);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// TODO: add delete


// define the productSlice. This is a combination of actions and reducers. More info: https://redux-toolkit.js.org/api/createSlice
export const productSlice = createSlice({
  name: 'product',
  initialState,
  /**
   * The `reducers` field lets us define reducers and generate associated actions.
   * Unlike the selectors defined at the bottom of this file, reducers only have access
   * to this specific reducer and not the entire store.
   * 
   * Again, we will not dispatch these directly, they will be dispatched by productService.
   */
  reducers: {
    invalidateQuery: (state, action) => {
      const queryKey = action.payload;
      const query = state.queries[queryKey];
      if(query) query.didInvalidate = true
    },
    addProductToList: (state, action) => {
      const { listArgs: queryKey, id } = action.payload;
      const query = state.queries[queryKey];
      if(query) {
        query.ids.push(id)
      } else {
        console.log('Could not find list');
      }
    }
  },

  /**
   * The `extraReducers` field lets the slice handle actions defined elsewhere,
   * including actions generated by createAsyncThunk or in other slices.
   * We'll use them to track our server request status.
   */
  extraReducers: (builder) => {
    builder
      // CREATE
      .addCase(sendCreateProduct.fulfilled, (state, action) => {
        // console.log('action', action);
        const product = action.payload;
        state.queries[product._id] = {}
        const singleQuery = state.queries[product._id];
        singleQuery.id = product._id;
        state.byId = { ...state.byId, [product._id]: product };
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(sendCreateProduct.rejected, (state, action) => {
        // TODO: handle server errors
      })

      // READ
      .addCase(fetchDefaultProduct.pending, (state, action) => {
        // create a query object for it in the queries map
        state.queries['defaultItem'] = {};
        // set the status to pending
        state.queries['defaultItem'].status = 'pending';
      })
      .addCase(fetchDefaultProduct.fulfilled, (state, action) => {
        const defaultProduct = action.payload;
        const singleQuery = state.queries['defaultItem'];
        singleQuery.id = 'defaultItem';
        state.byId = { ...state.byId, defaultItem: defaultProduct };
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Infinity; // this should never expire. It's just an empty product.
      })
      .addCase(fetchSingleProduct.pending, (state, action) => {
        // create a query object for it in the queries map
        state.queries[action.meta.arg] = {}
        state.queries[action.meta.arg].status = 'pending';
      })
      .addCase(fetchSingleProduct.fulfilled, (state, action) => {
        const product = action.payload
        // find the query object for this fetch in the queries map
        const singleQuery = state.queries[action.meta.arg];
        // set the query id
        singleQuery.id = product._id;
        // add the product object to the byId map
        state.byId = { ...state.byId, [product._id]: product };
        // update other query info
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(fetchProductList.pending, (state, action) => {
        // update or create the query object for it in the queries map
        state.queries[action.meta.arg] = { ...state.queries[action.meta.arg], status: 'pending' };

      })
      .addCase(fetchProductList.fulfilled, (state, action) => {
        const {products, totalPages} = action.payload;
        // update list query
         // convert the array of objects to a map
        const productMap = convertListToMap(products, '_id');
        // add the product objects to the byId map
        state.byId = { ...state.byId, ...productMap };

        // find the query object for this fetch in the queries map
        const listQuery = state.queries[action.meta.arg];
        // save the array of ids for the returned products
        listQuery.ids = products.map(product => product._id);
        // set the rest of the query info
        listQuery.totalPages = totalPages;
        listQuery.status = 'fulfilled';
        listQuery.receivedAt = Date.now();
        listQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now

        // while we're here we might as well add a single query for each of these since we know they're fresh
        products.forEach(product => {
          // add a single query for the product.
          const singleQuery = {
            id: product._id
            , status: listQuery.status
            , receivedAt: listQuery.receivedAt
            , expirationDate: listQuery.expirationDate
          };
          
          state.queries[product._id] = singleQuery;
          // add the product to the map 
          state.byId[product._id] = product
        });
      })
      .addCase(fetchProductList.rejected, (state, action) => {
        // TODO: handle server errors
        const listQuery = state.queries[action.meta.arg];
        listQuery.status = 'rejected';
        listQuery.receivedAt = Date.now();
      })
      
      // UPDATE
      .addCase(sendUpdateProduct.pending, (state, action) => {
        const {_id} = action.meta.arg;
        state.queries[_id] = state.queries[_id] || {};
        state.queries[_id].status = 'pending';
      })
      .addCase(sendUpdateProduct.fulfilled, (state, action) => {
        const product = action.payload;
        const singleQuery = state.queries[product._id];
        singleQuery.id = product._id;
        state.byId = { ...state.byId, [product._id]: product };
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(sendUpdateProduct.rejected, (state, action) => {
        // TODO: handle server errors
      })
    // TODO: add delete
  },
});

export const { invalidateQuery, addProductToList } = productSlice.actions;

/**
 * The functions below are called a selectors and allow us to select a value from
 * the store. Selectors can also be defined inline where they're used instead of
 * in the slice file. For example: `useSelector((store: RootState) => store.product.value)`
 * 
 * These are the replacement for the old mapStoreToProps functionality.
 * 
 * Because selectors take the whole store as their first argument, and our
 * stores are all structured the same way, we could define these at the global
 * level and pass in the store we want to access when we use them.
 * 
 * for example in productService:
 * 
 * const singleProduct = useSelector(store => selectSingleById(store.product, productId))
 * 
 * But to minimize the risk of over-generalizing, we'll define a set in each store.
 */

export const selectListItems = ({product2: productStore}, listArgs) => {
  const listIds = productStore.queries[listArgs]?.ids;
  if(listIds) {
    return listIds.map(id => productStore.byId[id]);
  } else {
    return null;
  }
}

export const selectListPageCount = ({product2: productStore}, listArgs) => {
  return productStore.queries[listArgs]?.totalPages;
}

export const selectShouldFetch = ({ product2: productStore }, queryKey) => {
  if(!queryKey) return false;
  const productQuery = productStore.queries[queryKey];
  // use the util to check if we should fetch or not
  return shouldFetch(productQuery);
}


export const selectSingleById = ({product2: productStore}, id) => {
  return productStore.byId[id];
}

// queryKey will either be a single id or an array of listArgs. productStore.queries doesn't care either way
export const selectFetchStatus = ({ product2: productStore }, queryKey) => {
  return productStore.queries[queryKey]?.status;
}

export default productSlice.reducer;
